"use strict";
var _Auth_secret;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const tslib_1 = require("tslib");
const utilities_1 = require("@sapphire/utilities");
const crypto_1 = require("crypto");
const v9_1 = require("discord-api-types/v9");
const node_fetch_1 = (0, tslib_1.__importDefault)(require("node-fetch"));
class Auth {
    constructor(options) {
        /**
         * The client's application id, this can be retrieved in Discord Developer Portal at https://discord.com/developers/applications.
         * @since 1.0.0
         */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The name for the cookie, this will be used to identify a Secure HttpOnly cookie.
         * @since 1.0.0
         */
        Object.defineProperty(this, "cookie", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The scopes defined at https://discord.com/developers/docs/topics/oauth2#shared-resources-oauth2-scopes.
         * @since 1.0.0
         */
        Object.defineProperty(this, "scopes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The redirect uri.
         * @since 1.0.0
         */
        Object.defineProperty(this, "redirect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The transformers used for {@link Auth.fetchData}.
         * @since 1.4.0
         */
        Object.defineProperty(this, "transformers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "domainOverwrite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        _Auth_secret.set(this, void 0);
        this.id = options.id;
        this.cookie = options.cookie ?? 'SAPPHIRE_AUTH';
        this.scopes = options.scopes ?? ['identify'];
        this.redirect = options.redirect;
        (0, tslib_1.__classPrivateFieldSet)(this, _Auth_secret, options.secret, "f");
        this.transformers = options.transformers ?? [];
        this.domainOverwrite = options.domainOverwrite ?? null;
    }
    /**
     * The client secret, this can be retrieved in Discord Developer Portal at https://discord.com/developers/applications.
     * @since 1.0.0
     */
    get secret() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Auth_secret, "f");
    }
    /**
     * Encrypts an object with aes-256-cbc to use as a token.
     * @since 1.0.0
     * @param data An object to encrypt
     * @param secret The secret to encrypt the data with
     */
    encrypt(data) {
        const iv = (0, crypto_1.randomBytes)(16);
        const cipher = (0, crypto_1.createCipheriv)('aes-256-cbc', (0, tslib_1.__classPrivateFieldGet)(this, _Auth_secret, "f"), iv);
        return `${cipher.update(JSON.stringify(data), 'utf8', 'base64') + cipher.final('base64')}.${iv.toString('base64')}`;
    }
    /**
     * Decrypts an object with aes-256-cbc to use as a token.
     * @since 1.0.0
     * @param token An data to decrypt
     * @param secret The secret to decrypt the data with
     */
    decrypt(token) {
        const [data, iv] = token.split('.');
        const decipher = (0, crypto_1.createDecipheriv)('aes-256-cbc', (0, tslib_1.__classPrivateFieldGet)(this, _Auth_secret, "f"), Buffer.from(iv, 'base64'));
        try {
            const parsed = JSON.parse(decipher.update(data, 'base64', 'utf8') + decipher.final('utf8'));
            // If the token expired, return null:
            return parsed.expires >= Date.now() ? parsed : null;
        }
        catch {
            return null;
        }
    }
    /**
     * Retrieves the data for a specific user.
     * @since 1.4.0
     * @param token The access token from the user.
     */
    async fetchData(token) {
        // Fetch the information:
        const [user, guilds, connections] = await Promise.all([
            this.fetchInformation('identify', token, `${v9_1.RouteBases.api}${v9_1.Routes.user()}`),
            this.fetchInformation('guilds', token, `${v9_1.RouteBases.api}${v9_1.Routes.userGuilds()}`),
            this.fetchInformation('connections', token, `${v9_1.RouteBases.api}${v9_1.Routes.userConnections()}`)
        ]);
        // Transform the information:
        let data = { user, guilds, connections };
        for (const transformer of this.transformers) {
            const result = transformer(data);
            if ((0, utilities_1.isThenable)(result))
                data = await result;
            else
                data = result;
        }
        return data;
    }
    async fetchInformation(scope, token, url) {
        if (!this.scopes.includes(scope))
            return undefined;
        const result = await (0, node_fetch_1.default)(url, {
            headers: {
                authorization: `Bearer ${token}`
            }
        });
        return result.ok ? (await result.json()) : null;
    }
    static create(options) {
        if (!options?.secret || !options.id)
            return null;
        return new Auth(options);
    }
}
exports.Auth = Auth;
_Auth_secret = new WeakMap();
//# sourceMappingURL=Auth.js.map