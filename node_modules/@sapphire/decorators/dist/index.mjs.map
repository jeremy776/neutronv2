{"version":3,"sources":["../src/utils.ts","../src/base-decorators.ts","../src/djs-decorators.ts","../src/piece-decorators.ts"],"sourcesContent":["/**\n * The function precondition interface.\n */\nexport interface FunctionPrecondition {\n\t/**\n\t * The arguments passed to the function or class' method.\n\t */\n\t(...args: any[]): boolean | Promise<boolean>;\n}\n\n/**\n * The fallback interface, this is called when the function precondition returns or resolves with a falsy value.\n */\nexport interface FunctionFallback {\n\t/**\n\t * The arguments passed to the function or class' method.\n\t */\n\t(...args: any[]): unknown;\n}\n\n/**\n * Utility to make a method decorator with lighter syntax and inferred types.\n *\n * ```typescript\n * // Enumerable function\n *\tfunction enumerableMethod(value: boolean) {\n *\t\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n *\t\t\tdescriptor.enumerable = value;\n *\t\t});\n *\t}\n * ```\n * @param fn The method to decorate\n */\nexport function createMethodDecorator(fn: MethodDecorator): MethodDecorator {\n\treturn fn;\n}\n\n/**\n * Utility to make a class decorator with lighter syntax and inferred types.\n * @param fn The class to decorate\n * @see {@link ApplyOptions}\n */\nexport function createClassDecorator<TFunction extends (...args: any[]) => void>(fn: TFunction): ClassDecorator {\n\treturn fn;\n}\n\n/**\n * Utility to make function preconditions.\n *\n * ```typescript\n * // No fallback (returns undefined)\n * function requireGuild(value: number) {\n *   return createFunctionPrecondition((message: Message) =>\n *     message.guild !== null\n *   );\n * }\n *\n * // With fallback\n * function requireGuild(\n *   value: number,\n *   fallback: () => unknown = () => undefined\n * ) {\n *   return createFunctionPrecondition(\n *     (message: Message) => message.guild !== null,\n *     fallback\n *   );\n * }\n * ```\n * @since 1.0.0\n * @param precondition The function that defines whether or not the function should be run, returning the returned value from fallback\n * @param fallback The fallback value that defines what the method should return in case the precondition fails\n */\nexport function createFunctionPrecondition(precondition: FunctionPrecondition, fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n\t\tconst method = descriptor.value;\n\t\tif (!method) throw new Error('Function preconditions require a [[value]].');\n\t\tif (typeof method !== 'function') throw new Error('Function preconditions can only be applied to functions.');\n\n\t\tdescriptor.value = async function descriptorValue(this: (...args: any[]) => any, ...args: any[]) {\n\t\t\tconst canRun = await precondition(...args);\n\t\t\treturn canRun ? method.call(this, ...args) : fallback.call(this, ...args);\n\t\t} as unknown as undefined;\n\t});\n}\n\n/**\n * Creates a new proxy to efficiently add properties to class without creating subclasses\n * @param target The constructor of the class to modify\n * @param handler The handler function to modify the constructor behavior for the target\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function createProxy<T extends object>(target: T, handler: Omit<ProxyHandler<T>, 'get'>): T {\n\treturn new Proxy(target, {\n\t\t...handler,\n\t\tget: (target, property) => {\n\t\t\tconst value = Reflect.get(target, property);\n\t\t\treturn typeof value === 'function' ? (...args: readonly unknown[]) => value.apply(target, args) : value;\n\t\t}\n\t});\n}\n","import type { NonNullObject } from '@sapphire/utilities';\nimport { createMethodDecorator } from './utils';\n\n/**\n * Decorator that sets the enumerable property of a class field to the desired value.\n * @param value Whether the property should be enumerable or not\n */\nexport function Enumerable(value: boolean) {\n\treturn (target: unknown, key: string) => {\n\t\tReflect.defineProperty(target as NonNullObject, key, {\n\t\t\tenumerable: value,\n\t\t\tset(this: unknown, val: unknown) {\n\t\t\t\tReflect.defineProperty(this as NonNullObject, key, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: value,\n\t\t\t\t\tvalue: val,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * Decorator that sets the enumerable property of a class method to the desired value.\n * @param value Whether the method should be enumerable or not\n */\nexport function EnumerableMethod(value: boolean) {\n\treturn createMethodDecorator((_target, _propertyKey, descriptor) => {\n\t\tdescriptor.enumerable = value;\n\t});\n}\n","import { isDMChannel, isGuildBasedChannel } from '@sapphire/discord.js-utilities';\nimport { UserError } from '@sapphire/framework';\nimport { Message, PermissionResolvable, Permissions } from 'discord.js';\nimport { createFunctionPrecondition, FunctionFallback } from './utils';\n\nexport const enum DecoratorIdentifiers {\n\tRequiresClientPermissionsGuildOnly = 'requiresClientPermissionsGuildOnly',\n\tRequiresClientPermissionsMissingPermissions = 'requiresClientPermissionsMissingPermissions',\n\tRequiresUserPermissionsGuildOnly = 'requiresUserPermissionsGuildOnly',\n\tRequiresUserPermissionsMissingPermissions = 'requiresUserPermissionsMissingPermissions'\n}\n\nconst DMAvailablePermissions = new Permissions(\n\t~new Permissions([\n\t\t//\n\t\t'ADD_REACTIONS',\n\t\t'ATTACH_FILES',\n\t\t'EMBED_LINKS',\n\t\t'READ_MESSAGE_HISTORY',\n\t\t'SEND_MESSAGES',\n\t\t'USE_EXTERNAL_EMOJIS',\n\t\t'VIEW_CHANNEL'\n\t]).bitfield & Permissions.ALL\n);\n\nconst DMAvailableUserPermissions = new Permissions(\n\t~new Permissions([\n\t\t'ADD_REACTIONS',\n\t\t'ATTACH_FILES',\n\t\t'EMBED_LINKS',\n\t\t'READ_MESSAGE_HISTORY',\n\t\t'SEND_MESSAGES',\n\t\t'USE_EXTERNAL_EMOJIS',\n\t\t'VIEW_CHANNEL',\n\t\t'USE_EXTERNAL_STICKERS',\n\t\t'MENTION_EVERYONE'\n\t]).bitfield & Permissions.ALL\n);\n\n/**\n * Allows you to set permissions required for individual methods. This is particularly useful for subcommands that require specific permissions.\n * @remark This decorator applies to the client that is to execute the command. For setting permissions required user of the command see {@link RequiresUserPermissions}\n * @remark This decorator makes the decorated function asynchronous, so any result should be `await`ed.\n * @param permissionsResolvable Permissions that the method should have.\n * @example\n * ```typescript\n * import { ApplyOptions, RequiresClientPermissions } from '@sapphire/decorators';\n * import { SubCommandPluginCommand, SubCommandPluginCommandOptions } from '@sapphire/plugin-subcommands';\n * import type { Message } from 'discord.js';\n *\n * (at)ApplyOptions<SubCommandPluginCommandOptions>({\n * \taliases: ['cws'],\n * \tdescription: 'A basic command with some subcommands',\n * \tsubCommands: ['add', 'remove', 'reset', { input: 'show', default: true }]\n * })\n * export default class extends SubCommandPluginCommand {\n *     // Anyone should be able to view the result, but not modify\n * \tpublic async show(message: Message) {\n * \t\treturn message.channel.send('Showing!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async add(message: Message) {\n * \t\treturn message.channel.send('Adding!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async remove(message: Message) {\n * \t\treturn message.channel.send('Removing!');\n * \t}\n *\n * \t(at)RequiresClientPermissions('BAN_MEMBERS') // This subcommand requires the client to be able to ban members.\n * \tpublic async reset(message: Message) {\n * \t\treturn message.channel.send('Resetting!');\n * \t}\n * }\n * ```\n */\nexport const RequiresClientPermissions = (...permissionsResolvable: PermissionResolvable[]): MethodDecorator => {\n\tconst resolved = new Permissions(permissionsResolvable);\n\tconst resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailablePermissions.bitfield);\n\n\treturn createFunctionPrecondition((message: Message) => {\n\t\tif (resolvedIncludesServerPermissions && isDMChannel(message.channel)) {\n\t\t\tthrow new UserError({\n\t\t\t\tidentifier: DecoratorIdentifiers.RequiresClientPermissionsGuildOnly,\n\t\t\t\tmessage: 'Sorry, but that command can only be used in a server because I do not have sufficient permissions in DMs'\n\t\t\t});\n\t\t}\n\n\t\tif (isGuildBasedChannel(message.channel)) {\n\t\t\tconst missingPermissions = message.channel.permissionsFor(message.guild!.me!).missing(resolved);\n\n\t\t\tif (missingPermissions.length) {\n\t\t\t\tthrow new UserError({\n\t\t\t\t\tidentifier: DecoratorIdentifiers.RequiresClientPermissionsMissingPermissions,\n\t\t\t\t\tmessage: `Sorry, but I am not allowed to do that. I am missing the permissions: ${missingPermissions}`,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\tmissing: missingPermissions\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n};\n\n/**\n * Allows you to set permissions required for individual methods. This is particularly useful for subcommands that require specific permissions.\n * @remark This decorator applies to the user of the command. For setting permissions required for the client see {@link RequiresClientPermissions}\n * @remark This decorator makes the decorated function asynchronous, so any result should be `await`ed.\n * @param permissionsResolvable Permissions that the method should have.\n * @example\n * ```typescript\n * import { ApplyOptions, RequiresUserPermissions } from '@sapphire/decorators';\n * import { SubCommandPluginCommand, SubCommandPluginCommandOptions } from '@sapphire/plugin-subcommands';\n * import type { Message } from 'discord.js';\n *\n * (at)ApplyOptions<SubCommandPluginCommandOptions>({\n * \taliases: ['cws'],\n * \tdescription: 'A basic command with some subcommands',\n * \tsubCommands: ['add', 'remove', 'reset', { input: 'show', default: true }]\n * })\n * export default class extends SubCommandPluginCommand {\n *     // Anyone should be able to view the result, but not modify\n * \tpublic async show(message: Message) {\n * \t\treturn message.channel.send('Showing!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async add(message: Message) {\n * \t\treturn message.channel.send('Adding!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async remove(message: Message) {\n * \t\treturn message.channel.send('Removing!');\n * \t}\n *\n * \t(at)RequiresUserPermissions('BAN_MEMBERS') // This subcommand requires the user of the command to be able to ban members.\n * \tpublic async reset(message: Message) {\n * \t\treturn message.channel.send('Resetting!');\n * \t}\n * }\n * ```\n */\nexport const RequiresUserPermissions = (...permissionsResolvable: PermissionResolvable[]): MethodDecorator => {\n\tconst resolved = new Permissions(permissionsResolvable);\n\tconst resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailableUserPermissions.bitfield);\n\n\treturn createFunctionPrecondition((message: Message) => {\n\t\tif (resolvedIncludesServerPermissions && isDMChannel(message.channel)) {\n\t\t\tthrow new UserError({\n\t\t\t\tidentifier: DecoratorIdentifiers.RequiresUserPermissionsGuildOnly,\n\t\t\t\tmessage: 'Sorry, but that command can only be used in a server because you do not have sufficient permissions in DMs'\n\t\t\t});\n\t\t}\n\n\t\tif (isGuildBasedChannel(message.channel)) {\n\t\t\tconst missingPermissions = message.channel.permissionsFor(message.member!).missing(resolved);\n\n\t\t\tif (missingPermissions.length) {\n\t\t\t\tthrow new UserError({\n\t\t\t\t\tidentifier: DecoratorIdentifiers.RequiresUserPermissionsMissingPermissions,\n\t\t\t\t\tmessage: `Sorry, but you are not allowed to do that. You are missing the permissions: ${missingPermissions}`,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\tmissing: missingPermissions\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n};\n\n/**\n * Requires the message to be run in a guild context, this decorator requires the first argument to be a `Message` instance\n * @since 1.0.0\n * @param fallback The fallback value passed to `createFunctionInhibitor`\n */\nexport function RequiresGuildContext(fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createFunctionPrecondition((message: Message) => message.guild !== null, fallback);\n}\n\n/**\n * Requires the message to be run in a dm context, this decorator requires the first argument to be a `Message` instance\n * @since 1.0.0\n * @param fallback The fallback value passed to `createFunctionInhibitor`\n */\nexport function RequiresDMContext(fallback: FunctionFallback = (): void => undefined): MethodDecorator {\n\treturn createFunctionPrecondition((message: Message) => message.guild === null, fallback);\n}\n","import { container, type Piece } from '@sapphire/framework';\nimport type { Container } from '@sapphire/pieces';\nimport type { Ctor } from '@sapphire/utilities';\nimport { createClassDecorator, createProxy } from './utils';\n\n/**\n * Decorator function that applies given options to any Sapphire piece\n * @param options The options to pass to the piece constructor\n * @example\n * ```typescript\n * import { ApplyOptions } from '@sapphire/decorators';\n * import { Command } from '@sapphire/framework';\n * import type { Message } from 'discord.js';\n *\n * @ApplyOptions<Command.Options>({\n *   description: 'ping pong',\n *   enabled: true\n * })\n * export class UserCommand extends Command {\n *   public override async messageRun(message: Message) {\n *     const msg = await message.channel.send('Ping?');\n *\n *     return msg.edit(\n *       `Pong! Client Latency ${Math.round(this.container.client.ws.ping)}ms. API Latency ${msg.createdTimestamp - message.createdTimestamp}ms.`\n *     );\n *   }\n * }\n * ```\n * @example\n * ```typescript\n * import { ApplyOptions } from '@sapphire/decorators';\n * import { Listener } from '@sapphire/framework';\n * import { GatewayDispatchEvents, GatewayMessageDeleteDispatch } from 'discord-api-types/v9';\n *\n * @ApplyOptions<Listener.Options>(({ container }) => ({\n *   description: 'Handle Raw Message Delete events',\n *   emitter: container.client.ws,\n *   event: GatewayDispatchEvents.MessageDelete\n * }))\n * export class UserListener extends Listener {\n *   public override run(data: GatewayMessageDeleteDispatch['d']): void {\n *     if (!data.guild_id) return;\n *\n *     const guild = this.container.client.guilds.cache.get(data.guild_id);\n *     if (!guild || !guild.channels.cache.has(data.channel_id)) return;\n *\n *     // Do something with the data\n *   }\n * }\n * ```\n */\nexport function ApplyOptions<T extends Piece.Options>(optionsOrFn: T | ((parameters: ApplyOptionsCallbackParameters) => T)): ClassDecorator {\n\treturn createClassDecorator((target: Ctor<ConstructorParameters<typeof Piece>, Piece>) =>\n\t\tcreateProxy(target, {\n\t\t\tconstruct: (ctor, [context, baseOptions = {}]: [Piece.Context, Piece.Options]) =>\n\t\t\t\tnew ctor(context, {\n\t\t\t\t\t...baseOptions,\n\t\t\t\t\t...(typeof optionsOrFn === 'function' ? optionsOrFn({ container, context }) : optionsOrFn)\n\t\t\t\t})\n\t\t})\n\t);\n}\n\nexport interface ApplyOptionsCallbackParameters {\n\tcontainer: Container;\n\tcontext: Piece.Context;\n}\n"],"mappings":"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","names":[]}