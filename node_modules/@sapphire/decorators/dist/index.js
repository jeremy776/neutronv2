"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ApplyOptions: () => ApplyOptions,
  DecoratorIdentifiers: () => DecoratorIdentifiers,
  Enumerable: () => Enumerable,
  EnumerableMethod: () => EnumerableMethod,
  RequiresClientPermissions: () => RequiresClientPermissions,
  RequiresDMContext: () => RequiresDMContext,
  RequiresGuildContext: () => RequiresGuildContext,
  RequiresUserPermissions: () => RequiresUserPermissions,
  createClassDecorator: () => createClassDecorator,
  createFunctionPrecondition: () => createFunctionPrecondition,
  createMethodDecorator: () => createMethodDecorator,
  createProxy: () => createProxy
});

// src/utils.ts
function createMethodDecorator(fn) {
  return fn;
}
__name(createMethodDecorator, "createMethodDecorator");
function createClassDecorator(fn) {
  return fn;
}
__name(createClassDecorator, "createClassDecorator");
function createFunctionPrecondition(precondition, fallback = () => void 0) {
  return createMethodDecorator((_target, _propertyKey, descriptor) => {
    const method = descriptor.value;
    if (!method)
      throw new Error("Function preconditions require a [[value]].");
    if (typeof method !== "function")
      throw new Error("Function preconditions can only be applied to functions.");
    descriptor.value = /* @__PURE__ */ __name(async function descriptorValue(...args) {
      const canRun = await precondition(...args);
      return canRun ? method.call(this, ...args) : fallback.call(this, ...args);
    }, "descriptorValue");
  });
}
__name(createFunctionPrecondition, "createFunctionPrecondition");
function createProxy(target, handler) {
  return new Proxy(target, {
    ...handler,
    get: (target2, property) => {
      const value = Reflect.get(target2, property);
      return typeof value === "function" ? (...args) => value.apply(target2, args) : value;
    }
  });
}
__name(createProxy, "createProxy");

// src/base-decorators.ts
function Enumerable(value) {
  return (target, key) => {
    Reflect.defineProperty(target, key, {
      enumerable: value,
      set(val) {
        Reflect.defineProperty(this, key, {
          configurable: true,
          enumerable: value,
          value: val,
          writable: true
        });
      }
    });
  };
}
__name(Enumerable, "Enumerable");
function EnumerableMethod(value) {
  return createMethodDecorator((_target, _propertyKey, descriptor) => {
    descriptor.enumerable = value;
  });
}
__name(EnumerableMethod, "EnumerableMethod");

// src/djs-decorators.ts
var import_discord = require("@sapphire/discord.js-utilities");
var import_framework = require("@sapphire/framework");
var import_discord2 = require("discord.js");
var DecoratorIdentifiers = /* @__PURE__ */ ((DecoratorIdentifiers2) => {
  DecoratorIdentifiers2["RequiresClientPermissionsGuildOnly"] = "requiresClientPermissionsGuildOnly";
  DecoratorIdentifiers2["RequiresClientPermissionsMissingPermissions"] = "requiresClientPermissionsMissingPermissions";
  DecoratorIdentifiers2["RequiresUserPermissionsGuildOnly"] = "requiresUserPermissionsGuildOnly";
  DecoratorIdentifiers2["RequiresUserPermissionsMissingPermissions"] = "requiresUserPermissionsMissingPermissions";
  return DecoratorIdentifiers2;
})(DecoratorIdentifiers || {});
var DMAvailablePermissions = new import_discord2.Permissions(~new import_discord2.Permissions([
  "ADD_REACTIONS",
  "ATTACH_FILES",
  "EMBED_LINKS",
  "READ_MESSAGE_HISTORY",
  "SEND_MESSAGES",
  "USE_EXTERNAL_EMOJIS",
  "VIEW_CHANNEL"
]).bitfield & import_discord2.Permissions.ALL);
var DMAvailableUserPermissions = new import_discord2.Permissions(~new import_discord2.Permissions([
  "ADD_REACTIONS",
  "ATTACH_FILES",
  "EMBED_LINKS",
  "READ_MESSAGE_HISTORY",
  "SEND_MESSAGES",
  "USE_EXTERNAL_EMOJIS",
  "VIEW_CHANNEL",
  "USE_EXTERNAL_STICKERS",
  "MENTION_EVERYONE"
]).bitfield & import_discord2.Permissions.ALL);
var RequiresClientPermissions = /* @__PURE__ */ __name((...permissionsResolvable) => {
  const resolved = new import_discord2.Permissions(permissionsResolvable);
  const resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailablePermissions.bitfield);
  return createFunctionPrecondition((message) => {
    if (resolvedIncludesServerPermissions && (0, import_discord.isDMChannel)(message.channel)) {
      throw new import_framework.UserError({
        identifier: "requiresClientPermissionsGuildOnly" /* RequiresClientPermissionsGuildOnly */,
        message: "Sorry, but that command can only be used in a server because I do not have sufficient permissions in DMs"
      });
    }
    if ((0, import_discord.isGuildBasedChannel)(message.channel)) {
      const missingPermissions = message.channel.permissionsFor(message.guild.me).missing(resolved);
      if (missingPermissions.length) {
        throw new import_framework.UserError({
          identifier: "requiresClientPermissionsMissingPermissions" /* RequiresClientPermissionsMissingPermissions */,
          message: `Sorry, but I am not allowed to do that. I am missing the permissions: ${missingPermissions}`,
          context: {
            missing: missingPermissions
          }
        });
      }
    }
    return true;
  });
}, "RequiresClientPermissions");
var RequiresUserPermissions = /* @__PURE__ */ __name((...permissionsResolvable) => {
  const resolved = new import_discord2.Permissions(permissionsResolvable);
  const resolvedIncludesServerPermissions = Boolean(resolved.bitfield & DMAvailableUserPermissions.bitfield);
  return createFunctionPrecondition((message) => {
    if (resolvedIncludesServerPermissions && (0, import_discord.isDMChannel)(message.channel)) {
      throw new import_framework.UserError({
        identifier: "requiresUserPermissionsGuildOnly" /* RequiresUserPermissionsGuildOnly */,
        message: "Sorry, but that command can only be used in a server because you do not have sufficient permissions in DMs"
      });
    }
    if ((0, import_discord.isGuildBasedChannel)(message.channel)) {
      const missingPermissions = message.channel.permissionsFor(message.member).missing(resolved);
      if (missingPermissions.length) {
        throw new import_framework.UserError({
          identifier: "requiresUserPermissionsMissingPermissions" /* RequiresUserPermissionsMissingPermissions */,
          message: `Sorry, but you are not allowed to do that. You are missing the permissions: ${missingPermissions}`,
          context: {
            missing: missingPermissions
          }
        });
      }
    }
    return true;
  });
}, "RequiresUserPermissions");
function RequiresGuildContext(fallback = () => void 0) {
  return createFunctionPrecondition((message) => message.guild !== null, fallback);
}
__name(RequiresGuildContext, "RequiresGuildContext");
function RequiresDMContext(fallback = () => void 0) {
  return createFunctionPrecondition((message) => message.guild === null, fallback);
}
__name(RequiresDMContext, "RequiresDMContext");

// src/piece-decorators.ts
var import_framework2 = require("@sapphire/framework");
function ApplyOptions(optionsOrFn) {
  return createClassDecorator((target) => createProxy(target, {
    construct: (ctor, [context, baseOptions = {}]) => new ctor(context, {
      ...baseOptions,
      ...typeof optionsOrFn === "function" ? optionsOrFn({ container: import_framework2.container, context }) : optionsOrFn
    })
  }));
}
__name(ApplyOptions, "ApplyOptions");
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApplyOptions,
  DecoratorIdentifiers,
  Enumerable,
  EnumerableMethod,
  RequiresClientPermissions,
  RequiresDMContext,
  RequiresGuildContext,
  RequiresUserPermissions,
  createClassDecorator,
  createFunctionPrecondition,
  createMethodDecorator,
  createProxy
});
//# sourceMappingURL=index.js.map